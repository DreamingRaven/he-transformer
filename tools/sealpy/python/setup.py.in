# ******************************************************************************
# Copyright 2019 Intel Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ******************************************************************************

from setuptools import setup, Extension
from setuptools.command.build_ext import build_ext
import sys
import setuptools
import os
import distutils.ccompiler

cpp_args = ['-std=c++1z']

PYSEAL_ROOT_DIR = os.path.abspath(os.path.dirname(__file__))


def find_pyseal_source_dir():
    """Return location of pyseal source directory."""
    if os.environ.get('PYSEAL_SOURCE_DIR'):
        pyseal_source_dir = os.environ.get('PYSEAL_SOURCE_DIR')
    else:
        pyseal_source_dir = os.path.join(PYSEAL_ROOT_DIR)

    found = os.path.exists(
        os.path.join(pyseal_source_dir, 'pyseal/pyseal.cpp'))
    if not found:
        print('Cannot find pyseal.cpp in {} make sure that '
              'SEAL_INSTALL_PATH is set correctly'.format(pyseal_source_dir))
        sys.exit(1)
    else:
        print('seal library found in {}'.format(pyseal_source_dir))
        return pyseal_source_dir


def find_seal_install_dir():
    """Return location of SEAL install directory."""
    if os.environ.get('SEAL_INSTALL_PATH'):
        pyseal_install_dir = os.environ.get('SEAL_INSTALL_PATH')
    else:
        pyseal_install_dir = os.path.join(PYSEAL_ROOT_DIR)

    found = os.path.exists(os.path.join(pyseal_install_dir, 'include/seal'))
    found &= os.path.exists(os.path.join(pyseal_install_dir, 'lib/libseal.a'))
    if not found:
        print('Cannot find SEAL library in {} make sure that '
              'SEAL_INSTALL_PATH is set correctly'.format(pyseal_install_dir))
        sys.exit(1)
    else:
        print('seal library found in {}'.format(pyseal_install_dir))
        return pyseal_install_dir


def find_pybind_headers_dir():
    """Return location of pybind11 headers."""
    if os.environ.get('PYBIND_HEADERS_PATH'):
        pybind_headers_dir = os.environ.get('PYBIND_HEADERS_PATH')
    else:
        pybind_headers_dir = os.path.join(PYSEAL_ROOT_DIR, 'pybind11')

    found = os.path.exists(
        os.path.join(pybind_headers_dir, 'include/pybind11'))
    if not found:
        print(
            'Cannot find pybind11 library in {} make sure that '
            'PYBIND_HEADERS_PATH is set correctly'.format(pybind_headers_dir))
        sys.exit(1)
    else:
        print('pybind11 library found in {}'.format(pybind_headers_dir))
        return pybind_headers_dir


def parallelCCompile(
        self,
        sources,
        output_dir=None,
        macros=None,
        include_dirs=None,
        debug=0,
        extra_preargs=None,
        extra_postargs=None,
        depends=None,
):
    """Build sources in parallel.
    Reference link:
    http://stackoverflow.com/questions/11013851/speeding-up-build-process-with-distutils
    Monkey-patch for parallel compilation.
    """
    # those lines are copied from distutils.ccompiler.CCompiler directly
    macros, objects, extra_postargs, pp_opts, build = self._setup_compile(
        output_dir, macros, include_dirs, sources, depends, extra_postargs)
    cc_args = self._get_cc_args(pp_opts, debug, extra_preargs)
    print('cc_args', cc_args)

    # parallel code
    import multiprocessing.pool

    def _single_compile(obj):
        try:
            src, ext = build[obj]
        except KeyError:
            return
        self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)

    # convert to list, imap is evaluated on-demand
    pool = multiprocessing.pool.ThreadPool()
    list(pool.imap(_single_compile, objects))
    return objects


distutils.ccompiler.CCompiler.compile = parallelCCompile

PYBIND11_INCLUDE_DIR = find_pybind_headers_dir() + '/include'

SEAL_INSTALL_DIR = find_seal_install_dir()
SEAL_INCLUDE_DIR = SEAL_INSTALL_DIR + '/include'
SEAL_LIB_DIR = SEAL_INSTALL_DIR + '/lib'
SEAL_LIB = SEAL_LIB_DIR + '/libseal.a'

PYSEAL_SRC_DIR = find_pyseal_source_dir()
print('PYSEAL_SRC_DIR', PYSEAL_SRC_DIR)

src_files = [
    'batch_encoder.cpp', 'biguint.cpp', 'ciphertext.cpp', 'ckks.cpp',
    'coeff_modulus.cpp', 'context_data.cpp', 'decryptor.cpp',
    'encryption_parameters.cpp', 'encryptor.cpp', 'evaluator.cpp',
    'galoiskeys.cpp', 'intencoder.cpp', 'key_generator.cpp', 'kswitchkeys.cpp',
    'memory_pool_handle.cpp', 'plain_modulus.cpp', 'plaintext.cpp',
    'public_key.cpp', 'pyseal.cpp', 'randomgen.cpp', 'relinkeys.cpp',
    'rlwe.cpp', 'seal_context.cpp', 'secret_key.cpp', 'small_modulus.cpp',
    'valcheck.cpp'
]
src_files = [
    os.path.join(PYSEAL_SRC_DIR, 'pyseal/' + src_file)
    for src_file in src_files
]

ext_modules = [
    Extension(
        'pyseal',
        sources=src_files,
        include_dirs=[PYSEAL_SRC_DIR, PYBIND11_INCLUDE_DIR, SEAL_INCLUDE_DIR],
        language='c++',
        extra_compile_args=cpp_args,
        extra_objects=[SEAL_LIB],
    )
]

with open(os.path.join(PYSEAL_SRC_DIR, 'requirements.txt')) as req:
    requirements = req.read().splitlines()

setup(
    name='pyseal',
    version='@SEAL_VERSION@',
    author='Intel Corporation',
    author_email='fabian.boemer@intel.com',
    license='License :: OSI Approved :: Apache Software License',
    description='Python wrapper for SEAL',
    long_description=open(os.path.join(PYSEAL_SRC_DIR, '../README.md')).read(),
    long_description_content_type='text/markdown',
    data_files=[SEAL_LIB],
    setup_requires=['numpy==1.16.4'],
    install_requires=requirements,
    ext_modules=ext_modules)
